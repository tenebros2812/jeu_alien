<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<title>Alien — mobile</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
<style>
  :root{
    --bg:#0F1E17; --panel:#12261E; --txt:#E6FFE9;
    --red:#B91C1C; --blk:#0B0B0B; --zero:#1F6F43;
    --outline:#39FF14; --stake:#00BFFF; --hole:#FFA500;
  }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--txt);
    font-family:-apple-system,system-ui,Segoe UI,Roboto,Helvetica,Arial}
  #page{min-height:100dvh;display:flex;flex-direction:column}
  #topbar{display:flex;align-items:center;justify-content:center;gap:10px;padding:8px;flex-wrap:wrap}
  .btn{background:#20425E;color:var(--txt);border:none;border-radius:10px;padding:8px 14px;font-weight:800}
  #zoom{flex:1;max-width:280px}
  #stakeSel{background:#20425E;color:var(--txt);border:none;border-radius:10px;padding:8px 10px;font-weight:900}

  /* zone centrale: HUD au-dessus, tapis en dessous, tout centré */
  #boardWrap{flex:1;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:8px;padding:6px}

  /* HUD non-superposé */
  #hud{
    background:rgba(0,0,0,.35); color:#E6FFE9;
    border:1px solid rgba(255,255,255,.12); border-radius:10px;
    padding:6px 8px; font-weight:800; font-size:12px; backdrop-filter: blur(2px);
    width:max-content; max-width:92vw;
  }
  #hud .row{margin-top:4px}
  #hud .pill{display:inline-block; min-width:18px; text-align:center; margin-left:6px;
             background:#20425E; border-radius:8px; padding:1px 6px; font-weight:900;}
  .gain{color:#39FF14} .loss{color:#FFA500}
  #hud .last{max-width:80vw; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}

  /* Tapis */
  #board{background:var(--panel);padding:8px;border-radius:12px;box-shadow:0 2px 8px rgba(0,0,0,.4);transform-origin:top center}
  .grid{display:grid;grid-template-columns:repeat(3, 44px);grid-auto-rows:32px;gap:3px}
  .cell{position:relative;width:44px;height:32px;display:flex;align-items:center;justify-content:center;
        color:var(--txt);font-weight:800;border-radius:6px;user-select:none;-webkit-tap-highlight-color:transparent;overflow:hidden}
  .zero{grid-column:1/span 3;width:calc(44px*3 + 3px*2);background:var(--zero)}
  .red{background:var(--red)} .blk{background:var(--blk)}
  .num{pointer-events:none;z-index:2}
  .hit{position:absolute;inset:0;border-radius:6px;cursor:pointer;z-index:3}

  /* surlignage */
  .outline-doz{outline:3px solid var(--outline);box-shadow:inset 0 0 0 3px var(--outline)}
  .outline-col{outline:3px solid var(--hole);box-shadow:inset 0 0 0 3px var(--hole)}
  .veil-doz::before{content:"";position:absolute;inset:0;background:rgba(57,255,20,0.18);z-index:1}
  .veil-col::before{content:"";position:absolute;inset:0;background:rgba(255,165,0,0.18);z-index:1}

  .badge{position:absolute;right:4px;top:3px;color:var(--stake);font-weight:900;font-size:12px;text-shadow:0 1px 0 rgba(0,0,0,.5);z-index:4}
  .press{animation:press .14s ease-in-out}
  @keyframes press{0%{filter:brightness(1)}50%{filter:brightness(.6)}100%{filter:brightness(1)}}

  /* refs pendant capture (simple outline verte fine) */
  .refpick{outline:2px solid rgba(57,255,20,0.55); box-shadow:inset 0 0 0 2px rgba(57,255,20,0.55)}
</style>
</head>
<body>
<div id="page">
  <div id="topbar">
    <button id="btnR" class="btn" title="Rafraîchir Alien (purge apprentissage + pending)">R</button>
    <button id="btnX" class="btn" title="Reset total">X</button>

    <select id="stakeSel" title="Mise de base">
      <option value="5">Mise 5</option>
      <option value="10">Mise 10</option>
      <option value="20">Mise 20</option>
    </select>

    <input id="zoom" type="range" min="60" max="180" value="100" title="Zoom">
  </div>

  <div id="boardWrap">
    <div id="hud">
      <div>Refs <span id="cnt" class="pill">0/12</span> • Best <span id="best" class="pill">0</span></div>
      <div class="row last" id="last">—</div>
      <div class="row" id="statusRow">—</div>
      <div class="row">Δ <span id="delta" class="pill">0</span> • Balance <span id="bal" class="pill">0</span></div>
    </div>

    <div id="board">
      <div class="grid" id="grid"></div>
    </div>
  </div>
</div>

<script>
/* ===== Constantes tapis ===== */
const ROUGE = new Set([1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36]);
const GRID = [
  [1,4,7,10,13,16,19,22,25,28,31,34],
  [2,5,8,11,14,17,20,23,26,29,32,35],
  [3,6,9,12,15,18,21,24,27,30,33,36],
];

const COL1 = new Set([1,4,7,10,13,16,19,22,25,28,31,34]);
const COL2 = new Set([2,5,8,11,14,17,20,23,26,29,32,35]);
const COL3 = new Set([3,6,9,12,15,18,21,24,27,30,33,36]);

const DOZ1 = new Set([1,2,3,4,5,6,7,8,9,10,11,12]);
const DOZ2 = new Set([13,14,15,16,17,18,19,20,21,22,23,24]);
const DOZ3 = new Set([25,26,27,28,29,30,31,32,33,34,35,36]);

function inGroup(g, n){
  if(n===0) return false;
  if(g==="DOZ1") return DOZ1.has(n);
  if(g==="DOZ2") return DOZ2.has(n);
  if(g==="DOZ3") return DOZ3.has(n);
  if(g==="COL1") return COL1.has(n);
  if(g==="COL2") return COL2.has(n);
  if(g==="COL3") return COL3.has(n);
  return false;
}
function spinToDozCol(n){
  if(n===0) return [null,null];
  const doz = DOZ1.has(n)?"DOZ1":(DOZ2.has(n)?"DOZ2":"DOZ3");
  const col = COL1.has(n)?"COL1":(COL2.has(n)?"COL2":"COL3");
  return [doz,col];
}

const WHIDDARTE = [1,1,2,2,4,4,8,8,16,16,32,32];

function clamp37(n){ n = Number(n)||0; n%=37; if(n<0) n+=37; return n; }
function getBaseStake(){
  const v = Number(document.getElementById('stakeSel').value);
  return (v===5||v===10||v===20)?v:5;
}
function unitForLvl(lvl){
  lvl = Math.max(0, Math.min(WHIDDARTE.length-1, lvl|0));
  return state.baseStake * WHIDDARTE[lvl];
}

/* ===== État Alien ===== */
const state = {
  spinIndex: -1,
  last5: [],
  lastDelta: 0,

  baseStake: 5,

  bank: 0,
  bestBank: 0,

  // Phase capture
  capturing: true,
  refs: [],
  refSet: new Set(),

  // Dernier événement observé après ref: ref -> {doz,col}
  after: new Map(),

  // per-ref: ref -> {lvl, profit}
  refState: new Map(),

  // pending bets: {due, ref, doz, col}
  pending: []
};

function autoInitOnNewBest(){
  if(state.bank > state.bestBank){
    state.bestBank = state.bank;
    for(const st of state.refState.values()) st.lvl = 0;
    state.pending = []; // purge pour éviter incohérences
  }
}

/* ===== UI build ===== */
function cellHTML(n){
  const cls=(n===0)?"cell zero":("cell "+(ROUGE.has(n)?"red":"blk"));
  return `<div class="${cls}" data-n="${n}">
    <div class="num">${n}</div>
    <div class="badge" style="display:none">0</div>
    <div class="hit"></div>
  </div>`;
}
function buildGrid(){
  const grid=document.getElementById('grid');
  grid.innerHTML="";
  grid.insertAdjacentHTML('beforeend', cellHTML(0));
  for(let r=0;r<12;r++){
    for(let c=0;c<3;c++){
      grid.insertAdjacentHTML('beforeend', cellHTML(GRID[c][r]));
    }
  }
  document.querySelectorAll('.cell .hit').forEach(hit=>{
    hit.addEventListener('click', ()=>{
      const cell=hit.parentElement;
      const n=parseInt(cell.getAttribute('data-n'),10);
      cell.classList.remove('press'); void cell.offsetWidth; cell.classList.add('press');
      pushNumber(n);
    });
  });
}

/* ===== Highlight ===== */
function clearMarks(){
  document.querySelectorAll('.cell').forEach(el=>{
    el.classList.remove('outline-doz','outline-col','veil-doz','veil-col','refpick');
    const b = el.querySelector('.badge');
    if(b) b.style.display='none';
  });
}

/* Calcule ce qu'on doit jouer AU PROCHAIN COUP (due = spinIndex+1) */
function dueNextPlan(){
  const nxt = state.spinIndex + 1;
  const due = state.pending.filter(p => p.due === nxt);

  if(!due.length) return {due:[], groups:[], bets:new Map()};

  // bets par numéro (1..36) = somme des mises (douz + col)
  const bets = new Map(); // n -> stakeTotal
  const groups = []; // list {ref, doz, col, stake, lvlMult}

  for(const p of due){
    const st = state.refState.get(p.ref) || {lvl:0};
    const stake = unitForLvl(st.lvl);
    const lvlMult = WHIDDARTE[Math.min(st.lvl, WHIDDARTE.length-1)];

    groups.push({ref:p.ref, doz:p.doz, col:p.col, stake, lvlMult});

    // ajoute stake sur tous numéros de la doz + col
    for(let n=1;n<=36;n++){
      let add = 0;
      if(p.doz && inGroup(p.doz, n)) add += stake;
      if(p.col && inGroup(p.col, n)) add += stake;
      if(add>0) bets.set(n, (bets.get(n)||0) + add);
    }
  }
  return {due, groups, bets};
}

function render(){
  clearMarks();

  if(state.capturing){
    // Pendant capture: juste marquer les refs choisies (pas de mises)
    for(const r of state.refs){
      const el = document.querySelector(`.cell[data-n="${r}"]`);
      if(el) el.classList.add('refpick');
    }
    updateHUD();
    return;
  }

  // Phase jeu: colorier DOZ/COL demandées au prochain coup + badges de mise
  const plan = dueNextPlan();

  // colorier en vert la/les douzaines, en orange la/les colonnes,
  // et l'intersection aura les deux effets (visuellement plus chargé, parfait)
  for(const g of plan.groups){
    for(let n=1;n<=36;n++){
      const el = document.querySelector(`.cell[data-n="${n}"]`);
      if(!el) continue;
      if(g.doz && inGroup(g.doz,n)){
        el.classList.add('outline-doz','veil-doz');
      }
      if(g.col && inGroup(g.col,n)){
        el.classList.add('outline-col','veil-col');
      }
    }
  }

  // badges mises
  for(const [n, v] of plan.bets.entries()){
    const el = document.querySelector(`.cell[data-n="${n}"]`);
    if(!el) continue;
    const b = el.querySelector('.badge');
    if(b){
      b.textContent = String(v);
      b.style.display = 'block';
    }
  }

  updateHUD(plan);
}

/* ===== HUD ===== */
function updateHUD(plan=null){
  const cnt=document.getElementById('cnt');
  const last=document.getElementById('last');
  const delta=document.getElementById('delta');
  const bal=document.getElementById('bal');
  const best=document.getElementById('best');
  const statusRow=document.getElementById('statusRow');

  cnt.textContent = `${state.refs.length}/12`;
  best.textContent = String(state.bestBank);

  last.textContent = state.last5.length ? state.last5.join(' ') : '—';

  if(state.capturing){
    statusRow.textContent = `Capture refs: clique 12 numéros (reste ${Math.max(0, 12 - state.refs.length)})`;
  } else {
    const p = plan || dueNextPlan();
    if(!p.due.length){
      statusRow.textContent = `En attente: aucun jeu demandé au prochain coup`;
    } else {
      // résumé lisible
      const parts = p.groups.map(g=>`${g.ref} → ${g.doz}+${g.col} (mise ${g.stake})`);
      statusRow.textContent = `Prochain coup: ${parts.join(" | ")}`;
    }
  }

  const d = state.lastDelta || 0;
  delta.textContent = d>=0?`+${d}`:`${d}`;
  delta.classList.toggle('gain', d>0);
  delta.classList.toggle('loss', d<0);

  bal.textContent = `${state.bank}`;
}

/* ===== Settlement Alien ===== */
function settleDue(spin){
  const i = state.spinIndex;
  if(!state.pending.length) return;

  const keep = [];
  for(const p of state.pending){
    if(p.due !== i){ keep.push(p); continue; }

    const st = state.refState.get(p.ref);
    if(!st) continue;

    const stake = unitForLvl(st.lvl);

    let delta = 0;

    if(spin === 0){
      // 0 = perte sur les deux chances
      delta = -2 * stake;
      st.lvl = Math.min(st.lvl + 1, WHIDDARTE.length-1);
    } else {
      const hitD = p.doz && inGroup(p.doz, spin);
      const hitC = p.col && inGroup(p.col, spin);

      delta += hitD ? (2*stake) : (-stake);
      delta += hitC ? (2*stake) : (-stake);

      // montante: si double touche => reset, sinon progresse
      if(hitD && hitC) st.lvl = 0;
      else st.lvl = Math.min(st.lvl + 1, WHIDDARTE.length-1);
    }

    st.profit += delta;
    state.bank += delta;
  }

  state.pending = keep;

  autoInitOnNewBest();
}

/* ===== Apprentissage: enregistrer DOZ/COL après une ref ===== */
function updateAfterMapping(prev, cur){
  if(!state.refSet.has(prev)) return;
  const [doz, col] = spinToDozCol(cur);
  if(!doz || !col) return; // si cur==0 => rien à enregistrer
  state.after.set(prev, {doz, col});
}

/* ===== Jeu: quand ref sort, programmer bet au coup suivant ===== */
function scheduleIfRef(cur){
  if(!state.refSet.has(cur)) return;
  const info = state.after.get(cur);
  if(!info) return; // pas encore appris ce qu'il y a "après"
  state.pending.push({
    due: state.spinIndex + 1,
    ref: cur,
    doz: info.doz,
    col: info.col
  });
}

/* ===== MAIN click ===== */
function pushNumber(n){
  state.baseStake = getBaseStake();
  const spin = clamp37(n);

  const prev = (state.spinIndex >= 0) ? state.last5[state.last5.length-1] : null;

  state.spinIndex += 1;

  // last5
  state.last5.push(spin);
  if(state.last5.length > 5) state.last5.shift();

  // settlement (si phase jeu)
  state.lastDelta = 0;
  if(!state.capturing){
    const before = state.bank;
    settleDue(spin);
    state.lastDelta = state.bank - before;
  }

  // capture refs
  if(state.capturing){
    if(!state.refSet.has(spin)){
      state.refs.push(spin);
      state.refSet.add(spin);
      state.refState.set(spin, {lvl:0, profit:0});
    }
    // apprentissage déjà possible même en capture
    if(prev !== null) updateAfterMapping(prev, spin);

    if(state.refs.length >= 12){
      state.capturing = false;
    }
    render();
    return;
  }

  // apprentissage: prev ref -> on enregistre le coup suivant
  if(prev !== null) updateAfterMapping(prev, spin);

  // si spin est une ref, on programme le bet pour le prochain coup
  scheduleIfRef(spin);

  render();
}

/* ===== Contrôles ===== */
document.getElementById('btnR').addEventListener('click', ()=>{
  // refresh Alien: purge apprentissage + pending, sans reset total ni refs
  state.after = new Map();
  state.pending = [];
  state.lastDelta = 0;
  render();
});

document.getElementById('btnX').addEventListener('click', ()=>{
  // reset total (important)
  state.spinIndex = -1;
  state.last5 = [];
  state.lastDelta = 0;
  state.baseStake = getBaseStake();

  state.bank = 0;
  state.bestBank = 0;

  state.capturing = true;
  state.refs = [];
  state.refSet = new Set();
  state.after = new Map();
  state.refState = new Map();
  state.pending = [];

  render();
});

document.getElementById('stakeSel').addEventListener('change', ()=>{
  state.baseStake = getBaseStake();
  render();
});

document.getElementById('zoom').addEventListener('input', e=>{
  const f=e.target.value/100.0;
  document.getElementById('board').style.transform=`scale(${f})`;
});

/* Init */
buildGrid();
render();
</script>
</body>
</html>
