<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<title>Alien — mobile</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
<style>
  :root{
    --bg:#0F1E17; --panel:#12261E; --txt:#E6FFE9;
    --red:#B91C1C; --blk:#0B0B0B; --zero:#1F6F43;
    --neon:#39FF14;
    --betbg:#173A31;
  }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--txt);
    font-family:-apple-system,system-ui,Segoe UI,Roboto,Helvetica,Arial}
  #page{min-height:100dvh;display:flex;flex-direction:column}
  #topbar{display:flex;align-items:center;justify-content:center;gap:10px;padding:8px;flex-wrap:wrap}
  .btn{background:#20425E;color:var(--txt);border:none;border-radius:10px;padding:8px 14px;font-weight:800}
  #zoom{flex:1;max-width:280px}
  #stakeSel{background:#20425E;color:var(--txt);border:none;border-radius:10px;padding:8px 10px;font-weight:900}

  /* zone centrale: HUD au-dessus, tapis en dessous, tout centré */
  #boardWrap{flex:1;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:8px;padding:6px}

  /* HUD non-superposé */
  #hud{
    background:rgba(0,0,0,.35); color:#E6FFE9;
    border:1px solid rgba(255,255,255,.12); border-radius:10px;
    padding:6px 8px; font-weight:800; font-size:12px; backdrop-filter: blur(2px);
    width:max-content; max-width:92vw;
  }
  #hud .row{margin-top:4px}
  #hud .pill{display:inline-block; min-width:18px; text-align:center; margin-left:6px;
             background:#20425E; border-radius:8px; padding:1px 6px; font-weight:900;}
  .gain{color:var(--neon)} .loss{color:#FFA500}
  #hud .last{max-width:80vw; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}

  /* ===== Board container (centré) ===== */
  #board{
    background:var(--panel);
    padding:8px;
    border-radius:12px;
    box-shadow:0 2px 8px rgba(0,0,0,.4);
    transform-origin:top center;
  }

  /* Layout: grille + colonne DOZ à droite, puis row COL en bas */
  .boardLayout{
    display:grid;
    grid-template-columns: auto 56px; /* grille + panel DOZ */
    grid-template-rows: auto 32px;    /* grille + panel COL */
    column-gap:8px;
    row-gap:8px;
    align-items:start;
    justify-items:start;
  }

  /* ===== Grille numéros ===== */
  .grid{
    grid-column:1;
    grid-row:1;
    display:grid;
    grid-template-columns:repeat(3, 44px);
    grid-auto-rows:32px;
    gap:3px;
  }
  .cell{
    position:relative;
    width:44px;height:32px;
    display:flex;align-items:center;justify-content:center;
    color:var(--txt);
    font-weight:800;
    border-radius:6px;
    user-select:none;
    -webkit-tap-highlight-color:transparent;
    overflow:hidden;
  }
  .zero{grid-column:1/span 3;width:calc(44px*3 + 3px*2);background:var(--zero)}
  .red{background:var(--red)} .blk{background:var(--blk)}

  /* Numéros -20% */
  .num{pointer-events:none;z-index:2;font-size:13px;line-height:1;}
  .hit{position:absolute;inset:0;border-radius:6px;cursor:pointer;z-index:3}

  .press{animation:press .14s ease-in-out}
  @keyframes press{0%{filter:brightness(1)}50%{filter:brightness(.6)}100%{filter:brightness(1)}}

  /* refs pendant capture uniquement */
  .refpick{outline:2px solid rgba(57,255,20,0.55); box-shadow:inset 0 0 0 2px rgba(57,255,20,0.55)}

  /* ===== Panels groupes (DOZ / COL) ===== */
  .dozPanel{
    grid-column:2;
    grid-row:1;
    display:flex;
    flex-direction:column;
    gap:3px;
    margin-top:35px; /* alignement sous le 0 */
  }
  .dozBox{
    width:56px;
    height:calc(32px*4 + 3px*3);
    background:var(--betbg);
    border-radius:10px;
    border:2px solid rgba(0,0,0,0.35);
    position:relative;
    display:flex;
    align-items:center;
    justify-content:center;
    text-align:center;
    font-weight:900;
  }
  .colPanel{
    grid-column:1;
    grid-row:2;
    display:grid;
    grid-template-columns:repeat(3, 44px);
    gap:3px;
  }
  .colBox{
    width:44px;
    height:32px;
    background:var(--betbg);
    border-radius:10px;
    border:2px solid rgba(0,0,0,0.35);
    position:relative;
    display:flex;
    align-items:center;
    justify-content:center;
    text-align:center;
    font-weight:900;
  }
  .label{
    position:absolute; left:6px; top:6px;
    font-size:11px;
    color:rgba(230,255,233,0.85);
    font-weight:900;
  }
  .colBox .label{top:5px;font-size:10px}
  .stake{
    font-size:18px;
    color:var(--neon);
    text-shadow:0 1px 0 rgba(0,0,0,.45);
  }
  .colBox .stake{font-size:16px}

  /* Highlight group boxes (TOUT EN VERT FLUO) */
  .hl-neon{
    outline:3px solid var(--neon);
    box-shadow:inset 0 0 0 3px var(--neon), 0 0 10px rgba(57,255,20,.25);
  }
  .hl-neon::before{
    content:""; position:absolute; inset:0;
    background:rgba(57,255,20,0.10);
    border-radius:10px;
  }
</style>
</head>
<body>
<div id="page">
  <div id="topbar">
    <button id="btnR" class="btn" title="Rafraîchir Alien (purge apprentissage + pending)">R</button>
    <button id="btnX" class="btn" title="Reset total">X</button>

    <select id="stakeSel" title="Mise de base">
      <option value="5">Mise 5</option>
      <option value="10">Mise 10</option>
      <option value="20">Mise 20</option>
    </select>

    <input id="zoom" type="range" min="60" max="180" value="100" title="Zoom">
  </div>

  <div id="boardWrap">
    <div id="hud">
      <div>Refs <span id="cnt" class="pill">0/12</span> • Best <span id="best" class="pill">0</span></div>
      <div class="row last" id="last">—</div>
      <div class="row" id="statusRow">—</div>
      <div class="row">Δ <span id="delta" class="pill">0</span> • Balance <span id="bal" class="pill">0</span></div>
    </div>

    <div id="board">
      <div class="boardLayout">
        <div class="grid" id="grid"></div>

        <div class="dozPanel">
          <div class="dozBox" id="DOZ1"><div class="label">DOZ1</div><div class="stake" id="DOZ1v"></div></div>
          <div class="dozBox" id="DOZ2"><div class="label">DOZ2</div><div class="stake" id="DOZ2v"></div></div>
          <div class="dozBox" id="DOZ3"><div class="label">DOZ3</div><div class="stake" id="DOZ3v"></div></div>
        </div>

        <div class="colPanel">
          <div class="colBox" id="COL1"><div class="label">COL1</div><div class="stake" id="COL1v"></div></div>
          <div class="colBox" id="COL2"><div class="label">COL2</div><div class="stake" id="COL2v"></div></div>
          <div class="colBox" id="COL3"><div class="label">COL3</div><div class="stake" id="COL3v"></div></div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
/* ===== Constantes ===== */
const ROUGE = new Set([1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36]);
const GRID = [
  [1,4,7,10,13,16,19,22,25,28,31,34],
  [2,5,8,11,14,17,20,23,26,29,32,35],
  [3,6,9,12,15,18,21,24,27,30,33,36],
];
const COL1 = new Set([1,4,7,10,13,16,19,22,25,28,31,34]);
const COL2 = new Set([2,5,8,11,14,17,20,23,26,29,32,35]);
const COL3 = new Set([3,6,9,12,15,18,21,24,27,30,33,36]);
const DOZ1 = new Set([1,2,3,4,5,6,7,8,9,10,11,12]);
const DOZ2 = new Set([13,14,15,16,17,18,19,20,21,22,23,24]);
const DOZ3 = new Set([25,26,27,28,29,30,31,32,33,34,35,36]);

function inGroup(g, n){
  if(n===0) return false;
  if(g==="DOZ1") return DOZ1.has(n);
  if(g==="DOZ2") return DOZ2.has(n);
  if(g==="DOZ3") return DOZ3.has(n);
  if(g==="COL1") return COL1.has(n);
  if(g==="COL2") return COL2.has(n);
  if(g==="COL3") return COL3.has(n);
  return false;
}
function spinToDozCol(n){
  if(n===0) return [null,null];
  const doz = DOZ1.has(n)?"DOZ1":(DOZ2.has(n)?"DOZ2":"DOZ3");
  const col = COL1.has(n)?"COL1":(COL2.has(n)?"COL2":"COL3");
  return [doz,col];
}

const WHIDDARTE = [1,1,2,2,4,4,8,8,16,16,32,32];

function clamp37(n){ n = Number(n)||0; n%=37; if(n<0) n+=37; return n; }
function getBaseStake(){
  const v = Number(document.getElementById('stakeSel').value);
  return (v===5||v===10||v===20)?v:5;
}
function unitForLvl(lvl){
  lvl = Math.max(0, Math.min(WHIDDARTE.length-1, lvl|0));
  return state.baseStake * WHIDDARTE[lvl];
}

/* ===== État ===== */
const state = {
  spinIndex: -1,
  last5: [],
  lastDelta: 0,
  baseStake: 5,
  bank: 0,
  bestBank: 0,

  capturing: true,
  refs: [],
  refSet: new Set(),

  after: new Map(),     // ref -> {doz,col}
  refState: new Map(),  // ref -> {lvl, profit}
  pending: []           // {due, ref, doz, col}
};

function autoInitOnNewBest(){
  if(state.bank > state.bestBank){
    state.bestBank = state.bank;
    for(const st of state.refState.values()) st.lvl = 0;
    state.pending = [];
  }
}

/* ===== UI Build ===== */
function cellHTML(n){
  const cls=(n===0)?"cell zero":("cell "+(ROUGE.has(n)?"red":"blk"));
  return `<div class="${cls}" data-n="${n}">
    <div class="num">${n}</div>
    <div class="hit"></div>
  </div>`;
}
function buildGrid(){
  const grid=document.getElementById('grid');
  grid.innerHTML="";
  grid.insertAdjacentHTML('beforeend', cellHTML(0));
  for(let r=0;r<12;r++){
    for(let c=0;c<3;c++){
      grid.insertAdjacentHTML('beforeend', cellHTML(GRID[c][r]));
    }
  }
  document.querySelectorAll('.cell .hit').forEach(hit=>{
    hit.addEventListener('click', ()=>{
      const cell=hit.parentElement;
      const n=parseInt(cell.getAttribute('data-n'),10);
      cell.classList.remove('press'); void cell.offsetWidth; cell.classList.add('press');
      pushNumber(n);
    });
  });
}

/* ===== Group boxes refs ===== */
const box = {
  DOZ1: document.getElementById('DOZ1'),
  DOZ2: document.getElementById('DOZ2'),
  DOZ3: document.getElementById('DOZ3'),
  COL1: document.getElementById('COL1'),
  COL2: document.getElementById('COL2'),
  COL3: document.getElementById('COL3'),
};
const boxVal = {
  DOZ1: document.getElementById('DOZ1v'),
  DOZ2: document.getElementById('DOZ2v'),
  DOZ3: document.getElementById('DOZ3v'),
  COL1: document.getElementById('COL1v'),
  COL2: document.getElementById('COL2v'),
  COL3: document.getElementById('COL3v'),
};

function clearGroupBoxes(){
  for(const k of Object.keys(box)){
    box[k].classList.remove('hl-neon');
    boxVal[k].textContent = "";
  }
}

function renderRefPick(){
  // IMPORTANT: refs visibles uniquement pendant capture
  document.querySelectorAll('.cell').forEach(el=> el.classList.remove('refpick'));
  if(!state.capturing) return;
  for(const r of state.refs){
    const el = document.querySelector(`.cell[data-n="${r}"]`);
    if(el) el.classList.add('refpick');
  }
}

function dueNextGroupStakes(){
  const nxt = state.spinIndex + 1;
  const due = state.pending.filter(p => p.due === nxt);
  const gStakes = new Map(); // group -> total stake

  for(const p of due){
    const st = state.refState.get(p.ref) || {lvl:0};
    const stake = unitForLvl(st.lvl);
    if(p.doz) gStakes.set(p.doz, (gStakes.get(p.doz)||0) + stake);
    if(p.col) gStakes.set(p.col, (gStakes.get(p.col)||0) + stake);
  }
  return {due, gStakes};
}

function renderGroupBoxes(){
  clearGroupBoxes();
  if(state.capturing) return;

  const {due, gStakes} = dueNextGroupStakes();
  if(!due.length) return;

  for(const [g, v] of gStakes.entries()){
    if(!box[g]) continue;
    boxVal[g].textContent = String(v);
    // DOZ ET COL EN VERT FLUO
    box[g].classList.add('hl-neon');
  }
}

/* ===== HUD ===== */
function updateHUD(){
  const cnt=document.getElementById('cnt');
  const last=document.getElementById('last');
  const delta=document.getElementById('delta');
  const bal=document.getElementById('bal');
  const best=document.getElementById('best');
  const statusRow=document.getElementById('statusRow');

  cnt.textContent = `${state.refs.length}/12`;
  best.textContent = String(state.bestBank);
  last.textContent = state.last5.length ? state.last5.join(' ') : '—';

  if(state.capturing){
    statusRow.textContent = `Capture refs: clique 12 numéros (reste ${Math.max(0, 12 - state.refs.length)})`;
  } else {
    const nxt = state.spinIndex + 1;
    const due = state.pending.filter(p => p.due === nxt);
    if(!due.length){
      statusRow.textContent = `En attente: aucun jeu demandé au prochain coup`;
    } else {
      const parts = due.map(p=>{
        const st = state.refState.get(p.ref) || {lvl:0};
        const mult = WHIDDARTE[Math.min(st.lvl, WHIDDARTE.length-1)];
        const stake = unitForLvl(st.lvl);
        return `${p.ref} → ${p.doz}+${p.col} (x${mult} = ${stake})`;
      });
      statusRow.textContent = `Prochain coup: ${parts.join(" | ")}`;
    }
  }

  const d = state.lastDelta || 0;
  delta.textContent = d>=0?`+${d}`:`${d}`;
  delta.classList.toggle('gain', d>0);
  delta.classList.toggle('loss', d<0);

  bal.textContent = `${state.bank}`;
}

function render(){
  renderRefPick();
  renderGroupBoxes();
  updateHUD();
}

/* ===== Settlement (Whiddarte) ===== */
function settleDue(spin){
  const i = state.spinIndex;
  if(!state.pending.length) return;

  const keep = [];
  for(const p of state.pending){
    if(p.due !== i){ keep.push(p); continue; }

    const st = state.refState.get(p.ref);
    if(!st) continue;

    const stake = unitForLvl(st.lvl);
    let delta = 0;

    if(spin === 0){
      delta = -2 * stake;
      st.lvl = Math.min(st.lvl + 1, WHIDDARTE.length-1);
    } else {
      const hitD = p.doz && inGroup(p.doz, spin);
      const hitC = p.col && inGroup(p.col, spin);

      delta += hitD ? (2*stake) : (-stake);
      delta += hitC ? (2*stake) : (-stake);

      if(hitD && hitC) st.lvl = 0;
      else st.lvl = Math.min(st.lvl + 1, WHIDDARTE.length-1);
    }

    st.profit += delta;
    state.bank += delta;
  }

  state.pending = keep;
  autoInitOnNewBest();
}

/* ===== Apprentissage ===== */
function updateAfterMapping(prev, cur){
  if(!state.refSet.has(prev)) return;
  const [doz, col] = spinToDozCol(cur);
  if(!doz || !col) return;
  state.after.set(prev, {doz, col});
}
function scheduleIfRef(cur){
  if(!state.refSet.has(cur)) return;
  const info = state.after.get(cur);
  if(!info) return;
  state.pending.push({
    due: state.spinIndex + 1,
    ref: cur,
    doz: info.doz,
    col: info.col
  });
}

/* ===== Main ===== */
function pushNumber(n){
  state.baseStake = getBaseStake();
  const spin = clamp37(n);

  const prev = (state.spinIndex >= 0) ? state.last5[state.last5.length-1] : null;

  state.spinIndex += 1;

  state.last5.push(spin);
  if(state.last5.length > 5) state.last5.shift();

  state.lastDelta = 0;
  if(!state.capturing){
    const before = state.bank;
    settleDue(spin);
    state.lastDelta = state.bank - before;
  }

  if(state.capturing){
    if(!state.refSet.has(spin)){
      state.refs.push(spin);
      state.refSet.add(spin);
      state.refState.set(spin, {lvl:0, profit:0});
    }
    if(prev !== null) updateAfterMapping(prev, spin);

    // FIN CAPTURE: on éteint les refs (plus de surlignage)
    if(state.refs.length >= 12) state.capturing = false;

    render();
    return;
  }

  if(prev !== null) updateAfterMapping(prev, spin);
  scheduleIfRef(spin);

  render();
}

/* ===== Controls ===== */
document.getElementById('btnR').addEventListener('click', ()=>{
  state.after = new Map();
  state.pending = [];
  state.lastDelta = 0;
  render();
});
document.getElementById('btnX').addEventListener('click', ()=>{
  state.spinIndex = -1;
  state.last5 = [];
  state.lastDelta = 0;
  state.baseStake = getBaseStake();

  state.bank = 0;
  state.bestBank = 0;

  state.capturing = true;
  state.refs = [];
  state.refSet = new Set();
  state.after = new Map();
  state.refState = new Map();
  state.pending = [];

  render();
});
document.getElementById('stakeSel').addEventListener('change', ()=>{
  state.baseStake = getBaseStake();
  render();
});
document.getElementById('zoom').addEventListener('input', e=>{
  const f=e.target.value/100.0;
  document.getElementById('board').style.transform=`scale(${f})`;
});

/* Init */
buildGrid();
render();
</script>
</body>
</html>
